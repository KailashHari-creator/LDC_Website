import { Message } from 'js-message';
import { Events } from 'event-pubsub';
import Parser from './parser';
var eventParser = new Parser();
var Client = /** @class */ (function (_super) {
    function Client(config, log) {
        Object.assign(this, {
            Client: Client,
            config: config,
            queue: [],
            socket: false,
            connect: connect,
            emit: emit,
            log: log,
            retriesRemaining: config.maxRetries || 0,
            explicitlyDisconnected: false
        });
        eventParser = new Parser(this.config);
        return this;
    }
    return Client;
}(Events));
export { Client };
function emit(type, data) {
    this.log('dispatching event to ', this.id, this.path, ' : ', type, ',', data);
    var message = new Message;
    message.type = type;
    message.data = data;
    if (this.config.rawBuffer) {
        message = Buffer && new Buffer(type, this.config.encoding);
    }
    else {
        message = eventParser.format(message);
    }
    if (!this.config.sync) {
        this.socket.write(message);
        return;
    }
    this.queue.add(syncEmit.bind(this, message));
}
function syncEmit(message) {
    this.log('dispatching event to ', this.id, this.path, ' : ', message);
    this.socket.write(message);
}
function connect() {
    //init client object for scope persistance especially inside of socket events.
    var client = this;
    client.log('requested connection to ', client.id, client.path);
    if (!this.path) {
        client.log('\n\n######\nerror: ', client.id, ' client has not specified socket path it wishes to connect to.');
        return;
    }
    client.socket.setEncoding(this.config.encoding);
    client.socket.on('error', function (err) {
        client.log('\n\n######\nerror: ', err);
        client.publish('error', err);
    });
    client.socket.on('connect', function connectionMade() {
        client.publish('connect');
        client.retriesRemaining = client.config.maxRetries;
        client.log('retrying reset');
    });
    client.socket.on('close', function connectionClosed() {
        client.log('connection closed', client.id, client.path, client.retriesRemaining, 'tries remaining of', client.config.maxRetries);
        if (client.config.stopRetrying ||
            client.retriesRemaining < 1 ||
            client.explicitlyDisconnected) {
            client.publish('disconnect');
            client.log((client.config.id), 'exceeded connection rety amount of', ' or stopRetrying flag set.');
            client.socket.destroy();
            client.publish('destroy');
            client = undefined;
            return;
        }
        setTimeout(function retryTimeout() {
            client.retriesRemaining--;
            client.connect();
        }.bind(null, client), client.config.retry);
        client.publish('disconnect');
    });
    client.socket.on('data', function (data) {
        client.log('## received events ##');
        if (client.config.rawBuffer) {
            client.publish('data', new Buffer(data, client.config.encoding));
            if (!client.config.sync) {
                return;
            }
            client.queue.next();
            return;
        }
        if (!this.ipcBuffer) {
            this.ipcBuffer = '';
        }
        data = (this.ipcBuffer += data);
        if (data.slice(-1) != eventParser.delimiter || data.indexOf(eventParser.delimiter) == -1) {
            client.log('Messages are large, You may want to consider smaller messages.');
            return;
        }
        this.ipcBuffer = '';
        var events = eventParser.parse(data);
        var eCount = events.length;
        for (var i = 0; i < eCount; i++) {
            var message = new Message;
            message.load(events[i]);
            client.log('detected event', message.type, message.data);
            client.publish(message.type, message.data);
        }
        if (!client.config.sync) {
            return;
        }
        client.queue.next();
    });
}
//# sourceMappingURL=client.js.map